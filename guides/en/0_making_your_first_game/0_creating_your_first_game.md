---
title: Создание вашей первой игры
description: Узнайте основы Kaplay и сделайте простую игру.
url: creating_your_first_game
---

# Создание вашей первой игры

Это вступительный учебник, который будет охватывать основные концепции и сделать очень
простую [Chrome Dino](https://en.wikipedia.org/wiki/Dinosaur_Game) -подобную игру.
Для настройки разработки Kaplay см.
[Руководство по установке](/guides/install).

![game](intro/game.png)

Начнем с инициализации контекста функцией `kaplay()`.

```js
kaplay();
```

Это должно дать вам чистый холст с таким красивым рисунком шахматной доски

![empty](intro/empty.png)

Теперь давайте добавим кое-что на экран, как изображение. Скопируйте этот кусок кода
в ваш редактор и посмотрите, что произойдет, когда вы запустите игру.

```js
// загрузка спрайта "bean" из изображения
loadSprite("bean", "sprites/bean.png");

// Добавить что -нибудь на экран
add([sprite("bean"), pos(80, 40)]);
```

Представляем лягушку "Bean"!Счастливая лягушка, которая наслаждается жизнью.
Вы увидите много Bean`ов здесь.

![isbean](intro/bean.png)

Прежде чем объяснить, что делает этот код, давайте попробуем добавить в него еще немного вещей
и посмотрите, что произойдет:

```js
// Добавить что -нибудь на экран
add([sprite("bean"), pos(80, 40), scale(3), rotate(30), color(0, 0, 255)]);
```

Не стесняйтесь настраивать некоторые параметры и посмотреть, как это влияет на то, что происходит на
экране.

В Kaplay каждый игровой объект состоит из нескольких компонентов. Каждый компонент
придает игровому объекту определенную функциональность.

> game object это сонова любого персонажа в игре, такого как персонаж игрока,
> пуля, скала, облако

Например, один компонент может определять форму, другой - должен ли объект испытывать гравитацию,
третий компонент может определять цвет, четвертый - продолжительность жизни и т.д.

![comps](intro/comps.png)

Если у вас возникли проблемы с пониманием, подумайте об этом Human Bean:

![humanbean](intro/humanbean.png)

Human также состоит из списка компонентов, каждый компонент предоставляет
различную функциональность, это именно то что представляет собой коспонент в KAPLAY.
`add()` это функция, которую вы используете для сборки всех компонентов в game
object в KAPLAY:

![assemble](intro/assemble.png)

Это как играть с кусочками lego! Давайте запомним об этом и
начнем делать фактического персонажа игрока в нашей игре:

```js
// соберем  нашего персонажа игрока
const bean = add([sprite("bean"), pos(80, 40), area(), body()]);

// .jump() when "space" key is pressed
onKeyPress("space", () => {
    bean.jump();
});
```

Посмотрим, какие компоненты мы используем:

- `sprite()` рендерится как спрайт, со спрайтом `"bean"` мы просто загружаем
  посредством `loadSprite()`
- `pos()` задает position на экране, в X: 80 Y: 40
- `area()` дает ему область коллайдера, поэтому мы можем проверить на столкновения 
    с другими персонажами
- `body()` дает физическое тело, заставляя его падать из -за гравитации и способность
    прыгать,

Мы также проверяем нашего персонажа с небольшим взаимодействием здесь.
`onKeyPress()` регистрирует событие, которое работает каждый раз, когда пользователь
нажимает определенную клавишу. 
В этом случае мы называем метод `.jump()` (предоставляемый компонентом `body()`)
когда клавиша пробела `"space"` нажата. Go ahead and slap that space key!

Компонент `body()`, наш Bean продолжит падать в бездну если мы не нажмем
клавишу пробела "space". Давайте добавим статическую платформу для Bean, 
чтобы он мог приземлиться.

```js
// добавляем платформу
add([
    rect(width(), 48),
    pos(0, height() - 48),
    outline(4),
    area(),
    body({ isStatic: true }),
    color(127, 200, 255),
]);
```

Ооо! Это похоже на много, но на самом деле это действительно просто, давайте посмотрим на каждый
компонент

- `rect()` рендерит прямоугольник. Принимает два аргумента, width и height,
  мы даем ему ширину игры (возвращаемую по `width()`) и высоту 48 пикселей
- `pos()` положение. Мы задаем x: 0 и y: `height() - 48` так что он находится прямо на
    нижней границе экрана
- `outline()` рендерит рамку в `4` пикселя
- `area()` добавляет коллайдер
- `body({ isStatic: true })` объект земли не движется, и все не статические объекты
    не пройдут сквозь него
- `color()` рендерит с цветом RGB, мы задаем его как R: 127 G: 200 B: 255 это голубой.

Осталось объявить гравитацию в нашем мире:

```js
setGravity(1600);
```

Обновите игру, и вы должны увидеть как наш Bean сейчас
безопасно приземлился на статической синей платформе.

![land](intro/land.png)

Давайте также удостоверимся, что наш Bean может прыгнуть 
только тогда, когда isGrounded.

```js
onKeyPress("space", () => {
    if (bean.isGrounded()) {
        bean.jump();
    }
});
```

`isGrounded()` это еще одна функция предоставляемая компонентом `body()` которая проверяет
приземлён ли наш Bean на платформе. 

Bean любит испытания. Давайте начнем добавлять препятствия, чтобы перепрыгнуть! 
Создадим игровые объекты из компонентов снова.

```js
// дерево
add([
    rect(48, 64),
    area(),
    outline(4),
    pos(width(), height() - 48),
    anchor("botleft"),
    color(255, 180, 255),
    move(LEFT, 240),
]);
```

Многие из них, мы уже видели, вы должны знать, что они делают, но некоторые новые
Один здесь:

- `anchor()` определяет точку позиционирования. По умолчанию `pos()` объявлен
  в верхнем левом углу формы, мы изменим это на левый нижний угол поскольку
  мы хотим чтобы дерево стояло на платформе, итак мы задаем Y position в
  `height() - 48`
- `move()` заставляет объект двигаться в направлении бесконечно. В этом случае мы двигаемся
в `LEFT` на `480` пикселей в секунду.

![tree](intro/tree.png)

Появилось препятсвтие! Попробуйте перепрыгнуть его.

О, но это ... не очень весело! Или, скорее, нет никаких отзывов о том, будь то
удалось перепрыгнуть через препятствие или нет. Давайте добавим немного отзывов.

Для этого нам нужно проверить столкновение между двумя объектами.

Сначала нам нужно дать дереву метку.У любого игрового объекта может быть любое количество
тегов, они вроде как компоненты, но гораздо более легкие.Мы часто используем теги, чтобы 
быстро описать поведение для группы объектов.

```js
// дерево
add([
    rect(48, 64),
    area(),
    outline(4),
    pos(width(), height() - 48),
    anchor("botleft"),
    color(255, 180, 255),
    move(LEFT, 240),
    "tree", // тэг
]);
```

Чтобы добавить тег, мы просто помещаем строку в массив компонентов.Тогда мы можем проверить
столкновения между Bean и любым объектом с тегом «tree».

```js
bean.onCollide("tree", () => {
    addKaboom(bean.pos);
    shake();
});
```

`.onCollide()` это функция предоставляемая компонентом `area()`. Она регистрирует
событие, которое срабатывает каждый раз, когда объект сталкивается с другим объектом с
определенным тегом, переданным в первом аргументе. В нашем случае, это значит, что каждый
раз когда Bean сталкивается с другим game obj с тегом `"tree"`, выполняется коллбэк.

Внутри коллбэка мы выполняем две вещи. `addKaboom()` порождает анимацию взрыва, 
она принимает 1 аргумент в отношении позиции, чтобы породиться, который мы передаем в
текущую позицию игрока с `.pos` (который обеспечивается компонентом `pos()`).

Вторая вещь это `shake()`, которая просто встряхивает экран,

![hit](intro/hit.gif)

Есть один трюк. Попробуйте нажать `F1` в игре. Видите белые линии? 
Это режим инспекции и он покажет все ограничивающие рамки каждого game obj with
`area()` component. Попробуйте навести курсор на любой game object чтобы инспектировать
его статы такие как положение и теги.

![inspect](intro/inspect.png)

Время добавить больше деревьев. Как мы можем постоянно их порождать?

Попробуйте функцию `loop()` , которая выполняет действие каждые x секунд.

```js
loop(1, () => {
    // дерево
    add([
        rect(48, 64),
        area(),
        outline(4),
        pos(width(), height() - 48),
        anchor("botleft"),
        color(255, 180, 255),
        move(LEFT, 240),
        "tree", // add a tag here
    ]);
});
```

Поместим код добавления деревьев в `loop()`. Первый аргумент это время в секундах,
так у нас генерится три дерева каждую секунду.

Это очень много деревьев. Теперь у нас уже есть большая часть игровой
механики. Мы можем добавить пару улучшений:

1. Былобы неплохо чтобы у каждого дерева случайно отличалась высота. 
Мы можем использовать `rand()` чтобы назначить различные значения 
для высоты прямоугольника дерева:

```js
rect(48, rand(24, 64)),
```

2. Было бы веселее если бы деревья генерировались с разными интервалами.
   Этого нельзя сделать с помощью `loop()`, но мы можем совместить его с
   рекурсивным `wait()`, который ожидает x секунд перед выполнением кода.

```js
function spawnTree() {
    add([
        // компоненты дерева
    ]);
    wait(rand(0.5, 1.5), () => {
        spawnTree();
    });
}

spawnTree();
```

Видите? Мы вызываем `spawnTree()` рекурсивно / бесконечно, с рандомными интервалами
от 0.5 до 1.5 секунд каждый раз.

Прежде чем добавить счетчик очков, давайте сначала заполним цикл игры, отсылая игрока
в game-over экран когда он попадает на дерево. Мы можем реализовать это с помощью
Системы сцен KAPLAY `scene()`

```js
scene("game", () => {
    add([sprite("bean")]);
});

scene("lose", () => {
    add([text("Game Over")]);
});

go("game");
```

Рассмотрим этот пример выше, мы объявляем две сцены, "game" и "lose".
Функция которую мы передаем в `scene()` это ункция для запуска, когда эта сцена
активируется (через `go()`). В этом случае, мы хоти добавить спрайт "bean"
к сцене "game", и хотим добавить текст "Game Over" в сцену "lose".

Сперва давайте поместим весь код игры в код сцены.

```js
kaplay();
loadSprite("bean", "sprites/bean.png");

scene("game", () => {
    // add bean
    // add platform
    // spawn trees
});

go("game");
```

Попробуйте это, это не должно менять ничего из контента вашей игры.

Затем мы можем добавить сцену "lose" независимо от вашего основного
игрового контента.

```js
scene("lose", () => {
    add([text("Game Over"), pos(center()), anchor("center")]);
});
```

В сцене "lose", мы добавим кусок текста в центр, говорящего "Game Over"
(`text()` это компонент который рендерит текст). Переходим на эту сцену, когда
игрок сталкивается с деревом:

```js
player.onCollide("tree", () => {
    addKaboom(bean.pos);
    shake();
    go("lose"); // go to "lose" scene here
});
```

Ok! Итак мы приближаемся к финальной части игры: счетчик очков.

```js
let score = 0;
const scoreLabel = add([text(score), pos(24, 24)]);
```

Здесь мы объявляем числовую переменную для хранения очков, 
и добавляем game obj с компонентом `text()` для отображения текста.

Будем проще и используем в качестве очков - время.

```js
// наращиваем очки каждый кадр
onUpdate(() => {
    score++;
    scoreLabel.text = score;
});
```

Для этого можно использовать функцию `onUpdate()`, которая принимает функцию,
и выпоняет ее в каждом кадре. 
В этом случае мы делаем приращение очков, и обновляем метку score label's text каждый кадр.

Вот полный код игры:

```js
const FLOOR_HEIGHT = 48;
const JUMP_FORCE = 800;
const SPEED = 480;

// initialize context
kaplay();

// load assets
loadSprite("bean", "sprites/bean.png");

scene("game", () => {
    // define gravity
    setGravity(1600);

    // add a game object to screen
    const player = add([
        // list of components
        sprite("bean"),
        pos(80, 40),
        area(),
        body(),
    ]);

    // floor
    add([
        rect(width(), FLOOR_HEIGHT),
        outline(4),
        pos(0, height()),
        anchor("botleft"),
        area(),
        body({ isStatic: true }),
        color(127, 200, 255),
    ]);

    function jump() {
        if (player.isGrounded()) {
            player.jump(JUMP_FORCE);
        }
    }

    // jump when user press space
    onKeyPress("space", jump);
    onClick(jump);

    function spawnTree() {
        // add tree obj
        add([
            rect(48, rand(32, 96)),
            area(),
            outline(4),
            pos(width(), height() - FLOOR_HEIGHT),
            anchor("botleft"),
            color(255, 180, 255),
            move(LEFT, SPEED),
            "tree",
        ]);

        // wait a random amount of time to spawn next tree
        wait(rand(0.5, 1.5), spawnTree);
    }

    // start spawning trees
    spawnTree();

    // lose if player collides with any game obj with tag "tree"
    player.onCollide("tree", () => {
        // go to "lose" scene and pass the score
        go("lose", score);
        burp();
        addKaboom(player.pos);
    });

    // keep track of score
    let score = 0;

    const scoreLabel = add([text(score), pos(24, 24)]);

    // increment score every frame
    onUpdate(() => {
        score++;
        scoreLabel.text = score;
    });
});

scene("lose", (score) => {
    add([
        sprite("bean"),
        pos(width() / 2, height() / 2 - 80),
        scale(2),
        anchor("center"),
    ]);

    // display score
    add([
        text(score),
        pos(width() / 2, height() / 2 + 80),
        scale(2),
        anchor("center"),
    ]);

    // go back to game with space is pressed
    onKeyPress("space", () => go("game"));
    onClick(() => go("game"));
});

go("game");
```
